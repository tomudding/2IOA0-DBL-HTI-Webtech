<!--
Author(s): Tom Udding, Sam Baggen, Tim van de Klundert
Created: 2019-05-01
Edited: 2019-05-10
-->
<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>graphion - visualisation</title>
	<link rel="stylesheet" type="text/css" href="/static/css/grid.css">
	<link rel="stylesheet" type="text/css" href="/static/css/grid_style.css">
	<link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700" rel="stylesheet">
	<!-- Bokeh files from Cloudflare CDN -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bokeh/1.1.0/bokeh.min.css" integrity="sha256-kmX/Nb5PazwKydPmaZjEb9sOg8BWh1v5eP14IzXJUkU=" crossorigin="anonymous" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bokeh/1.1.0/bokeh-tables.min.css" integrity="sha256-RL9kShsLcf2jHG2zzLh1peDLvWOEK0wPFWSZTiYykc4=" crossorigin="anonymous" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bokeh/1.1.0/bokeh-widgets.min.css" integrity="sha256-+DdrVMn0QeLZ5dYwdqkuugwJ4Im57giLBGqd9wH2YO0=" crossorigin="anonymous" />
	<script src="https://cdnjs.cloudflare.com/ajax/libs/bokeh/1.1.0/bokeh.min.js" integrity="sha256-VwiC87GeMmJLjJIRwyI9USfUlf9zpJbgZugDAz7W5CA=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/bokeh/1.1.0/bokeh-tables.min.js" integrity="sha256-1xlBn0odMnApk3dBf3oUDUQlsLvSwx2lvcBTIJC0x20=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/bokeh/1.1.0/bokeh-widgets.min.js" integrity="sha256-0D9ZpwC/v+rmx33UGlpWU9Uo1+J58MFqTKkGVGDZpEE=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/bokeh/1.1.0/bokeh-gl.min.js" integrity="sha256-fDyCLeWMeXB/F1JUTOFAM/9ONJmyiiSfsmPWl5tZQzk=" crossorigin="anonymous"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
</head>

<body>
	<!--
			THIS SECTION IS BASED ON MY OWN HTML/CSS FRAMEWORK
			NEEDS TO BE ADJUSTED TO WHAT ANTON COMES UP WITH
			UNLESS WE WANT TO USE THIS
			- Tom Udding
		-->
	<section class="body-wrapper">
		<div class="container">
			<div class="row">
				<div class="col-s-6" id="nodelink">
					<p id="nodelink-text">Loading nodelink diagram...</p>
					<div id="nodelink-load"><canvas id="nodelink-loading"></canvas></div>
					<div id="nodelink-plot"></div>
				</div>
				<div class="col-s-6" id="matrix">
					<p id="matrix-text">Loading matrix...</p>
					<div id="matrix-load"><canvas id="matrix-loading"></canvas></div>
					<div id="matrix-plot"></div>
				</div>
				<script>
					var canvas = document.getElementById('nodelink-loading');
					var context = canvas.getContext('2d');
					var div = document.getElementById("nodelink");
					var width = div.clientWidth - 5;
					var height = (div.clientHeight * 4) - 5;
					canvas.width = width;
					canvas.height = height;
					var graph = {
						velocity: 1,
						minRadius: 2,
						maxRadius: 5,
						connectDistance: 200,
						dots: width * height / (100 * 100),
						lineWidth: 2
					};
					window.requestAnimFrame = (function() {
						return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
							window.setTimeout(callback, 1000 / 60);
						};
					})();

					function random(min, max) {
						if (min > max) {
							min = [max, max = min][0];
						}
						return Math.random() * (max - min + 1) + min;
					}

					function round(x) {
						return Math.round(x);
					}

					function drawBackground() {
						context.beginPath();
						context.rect(0, 0, width, height);
						context.fillStyle = "rgba(255, 255, 255, 1)";
						context.fill();
					}

					function distance(dotA, dotB) {
						var dX = dotA.x - dotB.x;
						var dY = dotA.y - dotB.y;
						return Math.sqrt(dX * dX + dY * dY);
					}

					function line(dotA, dotB) {
						var gradient = context.createLinearGradient(dotA.x, dotA.y, dotB.x, dotB.y);
						gradient.addColorStop(0, dotA.color);
						gradient.addColorStop(1, dotB.color);
						context.strokeStyle = gradient;
						context.lineWidth = graph.lineWidth;
						context.lineCap = "round";
						context.beginPath();
						context.moveTo(dotA.x, dotA.y);
						context.lineTo(dotB.x, dotB.y);
						context.stroke();
					}

					function Dot() {
						this.r = random(graph.minRadius, graph.maxRadius);
						this.vx = random(-3, 3);
						this.vy = random(-3, 3);
						this.x = random(0, width);
						this.y = random(0, height);
						this.color = "rgb(" + [round(random(100, 220)), round(random(100, 220)), round(random(100, 220))].join() + ")";
						this.update = function() {
							this.x += this.vx * graph.velocity;
							this.y += this.vy * graph.velocity;
							if (this.x > width - this.r) {
								this.vx *= -1.0;
								this.x = width - this.r
							}
							if (this.y > height - this.r) {
								this.vy *= -1.0;
								this.y = height - this.r
							}
							if (this.x < this.r) {
								this.vx *= -1.0;
								this.x = this.r
							}
							if (this.y < this.r) {
								this.vy *= -1.0;
								this.y = this.r
							}
						};
						this.draw = function() {
							context.fillStyle = this.color;
							context.beginPath();
							context.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
							context.fill();
						};
						this.connect = function(i) {
							for (var j = i; j < dots.length; j++) {
								if (distance(this, dots[j]) < graph.connectDistance) {
									line(this, dots[j]);
								}
							}
						};
					}

					function createDots() {
						dots = [];
						for (var i = 0; i < graph.dots; i++) {
							dots.push(new Dot());
						}
					}

					function draw() {
						drawBackground();
						dots.forEach(function(dot) {
							dot.update();
						});
						dots.forEach(function(dot) {
							dot.draw();
						});
						dots.forEach(function(dot, i) {
							dot.connect(i);
						});
						if (document.getElementsByClassName('bk bk-canvas-events').length > 0) {
							div.remove();
						} else {
							requestAnimFrame(draw);
						}
					};
					var dots = [];
					createDots();
					draw();

					var matrixCanvas = document.getElementById("matrix-loading");
					var matrixContext = matrixCanvas.getContext('2d');
					var matrixDiv = document.getElementById("matrix");
					var matrixWidth = matrixDiv.clientWidth - 5;
					var matrixHeight = (matrixDiv.clientHeight) - 5;
					matrixCanvas.width = matrixWidth;
					matrixCanvas.height = matrixHeight;
					var matrix = {
						velocity: 1,
						minSize: 20,
						maxSize: 50,
						squares: (matrixWidth * matrixHeight) / (100 * 100)
					};

					function drawMatrixBackground() {
						matrixContext.beginPath();
						matrixContext.rect(0, 0, matrixWidth, matrixHeight);
						matrixContext.fillStyle = "rgba(255, 255, 255, 1)";
						matrixContext.fill();
					}

					function Square() {
						this.size = random(matrix.minSize, matrix.maxSize);
						this.vx = random(-3, 3);
						this.vy = random(3, -3);
						this.x = random(0, matrixWidth);
						this.y = random(0, matrixHeight);
						this.color = "rgb(" + [round(random(100, 220)), round(random(100, 220)), round(random(100, 220))].join() + ")";
						this.update = function() {
							this.x += this.vx * matrix.velocity;
							this.y += this.vy * matrix.velocity;
							if (this.x > matrixWidth - this.size) {
								this.vx *= -1.0;
								this.x = matrixWidth - this.size
							}
							if (this.y > matrixHeight - this.size) {
								this.vy *= -1.0;
								this.y = matrixHeight - this.size
							}
							if (this.x < this.size) {
								this.vx *= -1.0;
								this.x = this.size
							}
							if (this.y < this.size) {
								this.vy *= -1.0;
								this.y = this.size
							}
					};
						this.draw = function() {
							matrixContext.fillStyle = this.color;
							matrixContext.fillRect(this.x, this.y, this.size, this.size);
						};
					}

					function createSquares() {
						squares = [];
						for (var i = 0; i < graph.dots; i++) {
							squares.push(new Square());
						}
					}

					function drawMatrix() {
						drawMatrixBackground();
						squares.forEach(function(square) {
							square.update();
						});
						squares.forEach(function(square) {
							square.draw();
						});
						if (document.getElementsByClassName('bk bk-canvas-events').length > 0) {
							matrixDiv.remove();
						} else {
							requestAnimFrame(drawMatrix)
						}
					};
					var squares = [];
					createSquares();
					drawMatrix();
				</script>
				<div class="col-s-12">
					{{ script|safe }}
				</div>
			</div>
		</div>
	</section>
</body>

</html>
