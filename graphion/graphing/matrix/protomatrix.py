"""
Author(s): Steven van den Broek, Yuqin Cui
Created: 2019-05-05
Edited: 2019-05-05
"""
import numpy as np
import pandas as pd
import panel as pn
import param
import hvplot.pandas
from colorcet import palette
from scipy.spatial.distance import pdist, squareform
from fastcluster import linkage
from pandas import read_hdf
import time

def makeMatrix(file):

    df = read_hdf(file)
    big_bang = time.time()
    names = df.columns.tolist()
    if (len(names) > 400):
        df = df.head(400)[names[0:400]]
    names = df.columns.tolist()
    names = [name.replace('_', ' ') for name in names]
    df.columns = names

    df_original = df.copy()
    # %%
    # convert similarity into unsimilarity (1.0 - similarity)
    begin = time.time()
    for name in names:
        df[name] = 1 - df[name]
    print("Matrix, inverting values took: " + str(time.time()-begin))
    # %%
    # This is just the method online: https://gmarti.gitlab.io/ml/2017/09/07/how-to-sort-distance-matrix.html
    # We have to clean data and modified the method

    # %%
    # The output of linkage is stepwise dendrogram,
    # which is represented as an (N − 1) × 4 NumPy array with floating point entries (dtype=numpy.double).
    # The first two columns contain the node indices which are joined in each step. The input nodes are
    # labeled 0,..., N − 1, and the newly generated nodes have the labels N,...2N-2.
    # The third column contains the distance between the two nodes at each step, ie. the
    # current minimal distance at the time of the merge. The fourth column counts the
    # number of points which comprise each new node.

    # Idea is from: https://gmarti.gitlab.io/ml/2017/09/07/how-to-sort-distance-matrix.html

    # Traversal the hierarhical tree generated by linkage
    def traversal_tree(hier_tree, number_of_node, current_index):
        if current_index < number_of_node:
            return [current_index]
        else:
            return (traversal_tree(hier_tree, number_of_node, int(hier_tree[current_index - number_of_node][1])) +
                    traversal_tree(hier_tree, number_of_node, int(hier_tree[current_index - number_of_node][0])))

    # %%
    def compute_serial_matrix(df, method="ward", dist_metric="euclidean"):
        # define the dist_mat by different dist_metric mathod in fast_clustering package
        dist_mat = squareform(pdist(df, metric=dist_metric))
        # hierar tree was got from package "fast-clustering"
        hierar_tree = linkage(squareform(dist_mat), method=method, preserve_input=True)
        # The order implied by the hierarhical tree
        reordered_index = traversal_tree(hierar_tree, len(dist_mat), 2 * len(dist_mat) - 2)
        return reordered_index, hierar_tree

    # linkage(squareform(pdist(df, metric="euclidean")), method="ward",preserve_input=True)
    # %%
    # order original matrix based on index provided

    def reordercol(df, order):
        secondIndex = []
        new_df = df
        new_df['nindex'] = np.arange(len(new_df))
        for i in order:
            secondIndex += new_df.index[new_df['nindex'] == i].tolist()
        new_df.drop('nindex', axis=1, inplace=True)
        a = new_df.reindex(index=secondIndex)
        return a

    def reorderrow(df, order):
        a = df.values
        permutation = order
        return a[:, permutation]

    def reorder_input_df(df, order):
        reorder_col = reordercol(df, order)
        finish = reorderrow(reorder_col, order)
        return finish

    # %%
    def to_liquid(matrix):
        solid = pd.DataFrame(matrix)
        solid.index = names
        solid.columns = names
        solid.reset_index(inplace=True)
        liquid = solid.melt(id_vars='index', value_vars=list(df.columns[1:]), var_name="name2")
        liquid.columns = ['index1', 'index2', 'value']
        return liquid

    # %%
    def dis_to_similarity(grid):
        nrows = len(grid)
        ncols = len(grid[0])
        for i in range(nrows):
            for j in range(ncols):
                grid[i][j] = 1 - grid[i][j]
                # %%

    pn.extension()

    class Matrix_dropdown(param.Parameterized):
        reordering = param.ObjectSelector(default="none",
                                          objects=["none", "single", "average", "complete", "centroid", "weighted",
                                                   "median", "ward"])
        metric = param.ObjectSelector(default="euclidean",
                                      objects=["euclidean", "minkowski", "cityblock", "sqeuclidean", "cosine",
                                               "correlation", "hamming", "jaccard", "chebyshev", "canberra",
                                               "braycurtis"])

        def view(self):
            if self.reordering == "none":
                begin = time.time()
                liquid = to_liquid(df_original.values)
                print("Matrix, melting matrix: " + str(time.time() - begin))
                begin = time.time()
                result = liquid.hvplot.heatmap('index1', 'index2', 'value',
                                             height=500, width=600, flip_yaxis=True, xaxis=None, yaxis=None,
                                             cmap=palette['kbc'])
                print("Matrix, generating heatmap: " + str(time.time() - begin))
                return result
            else:
                small_bang = time.time()
                res_order, res_linkage = compute_serial_matrix(df, self.reordering, dist_metric=self.metric)
                print("Matrix, calculating reordering: " + str(time.time() - small_bang))
                begin = time.time()
                reordered_matrix_col = reordercol(df, res_order)
                print("Matrix, reordering columns: " + str(time.time() - begin))
                begin = time.time()
                reordered_matrix = reorderrow(reordered_matrix_col, res_order)
                print("Matrix, reordering rows: " + str(time.time() - begin))
                begin = time.time()
                dis_to_similarity(reordered_matrix)
                print("Matrix, to similarity: " + str(time.time() - begin))
                begin = time.time()
                liquid = to_liquid(reordered_matrix)
                print("Matrix, melting matrix: " + str(time.time() - begin))
                begin = time.time()
                result = liquid.hvplot.heatmap('index1', 'index2', 'value',
                                             height=500, width=600, flip_yaxis=True, xaxis=None, yaxis=None,
                                             cmap=palette['kbc'])
                print("Matrix, generating heatmap: " + str(time.time() - begin))
                print("------------------------------------")
                print("Matrix, reordering took in total: " + str(time.time() - small_bang))
                print()
                return result
    begin = time.time()
    matrix = Matrix_dropdown(name='Adjacency Matrix')
    pane = pn.Column(matrix.param, matrix.view)
    return pane
